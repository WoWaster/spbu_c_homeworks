# Худший случай для Merge Sort

> N.B. Для нормального отображения формул и рисунка стоит включить светлую тему (я сам не рад, но других вариантов нет)

Merge Sort в любом случае работает за <img src="https://render.githubusercontent.com/render/math?math=O(n\log{n})"> время, следовательно, самый плохой случай достигается при максимальном количестве сравнений.
Тогда &laquo;худший&raquo; массив должен быть таким, что при объединении частей сравнение будет происходить всегда, то есть шаги по правой и левой частям будет идти равномерно и никогда не будет ситуации когда в одной из объединяемых частей элементы уже кончились, а в другой нет.

## Алгоритм

Будем создавать &laquo;худший&raquo; массив из полностью отсортированного.

1. Возьмем массив состоящий из <img src="https://render.githubusercontent.com/render/math?math=n"> последовательных элементов.

2. Из него составим новый массив: сначала выберем все четные индексы, потом все нечетные.

3. Разделим полученный массив на 2 части: если длинна четная, то длина каждой части будет <img src="https://render.githubusercontent.com/render/math?math=\frac{n}{2}">, если длина нечетная, то пусть левая часть имеет длину <img src="https://render.githubusercontent.com/render/math?math=\lceil\frac{n}{2}\rceil">, а правая имеет длину <img src="https://render.githubusercontent.com/render/math?math=\lfloor\frac{n}{2}\rfloor">.

4. Применим действие из пункта 2 к каждой из полученных частей.

5. Будем рекурсивно выполнять этапы 3&ndash;4 до тех пор пока длина левого отрезка не достигнет 1 (при этом <img src="https://render.githubusercontent.com/render/math?math=n"> в пункте 3 будет означать длину конкретного подмассива).

6. &laquo;Худший&raquo; массив создан.

## Пример

Для облегчения задачи возьмем массив из 8 элементов. Построим массив по алгоритму выше:

![Пример](worst_case.svg)

Число в левом углу показывает номер элемента в подмассиве.
